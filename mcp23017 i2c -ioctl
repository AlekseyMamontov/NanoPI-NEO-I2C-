/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 * File:   main.c
 * Author: Aleksey Mamontov
 * Created on 24 июня 2018 г., 23:05
 */

/*////////////// 8bit mode (IOCON.BANK = 1) ////////////////////////////

#define IODIRA 0x00
#define IODIRB 0x10
#define IPOLA  0x01
#define IPOLB  0x11
#define GPINTENA 0x02
#define GPINTENB 0x12
#define DEFVALA 0x03
#define DEFVALB 0x13
#define INTCONA 0x04
#define INTCONB 0x14
#define IOCON 0x05
#define IOCON2 0x15
#define GPPUA 0x06
#define GPPUB 0x016
#define INTFA 0x07
#define INTFB 0x017
#define INTCAPA 0x08 
#define INTCAPB 0x18
#define GPIOA 0x09
#define GPIOB 0x19
#define OLATA 0x0a
#define OLATB 0x1a
 
 */
///////////////////// 16 bit mode  (IOCON.BANK = 0) ////////////////////

#define IODIRA 0x00 //  регистры указывают навправление входа и выхода для 16 портов
#define IODIRB 0x01 //  bit =1 - вход , bit = 0 выход, IODIRA - порты А0 - А7, ODIRB порты B0-В7

#define IPOLA  0x02 //  регистры отвечают за инверсию входных данных,  для портов  GPIOA - GPIOB
#define IPOLB  0x03 //  которые выставлены как вход (bit=1)  1 -> 0 или 0 ->1 :   (bit=0) 1->1 или 0->0

#define GPINTENA 0x04 //    Выставив  bit=1 мы определяем что данный порт может быть внешним прерыванием
#define GPINTENB 0x05 //    Прерывание происходит при смене напряжения.

#define DEFVALA 0x06 // В данных регистрах мы указываем при каком условии происходит прерывание
#define DEFVALB 0x07 // например bit=0 - то прерывание произойдет при  появление 1 (+3.3 до +5V)  на данном порту
                                    //  или bit=1 - тогда когда на порту появится 0 (GND,VSS) произойдет прерывание

#define INTCONA 0x08 // Если в этом регистре мы выставляем bit = 1 , то  определения для прерываний
#define INTCONB 0x09 // заданные в DEFVALA , DEFVAB игнорируются и прерывание происходит при условии
                                    // смены уровней тоесть 0 -> 1 прерывание  1-> 0 прерывание.

#define GPPUA 0x0c  // Подтягивать порты которые как входы к питанию через 100 кОм резистор
#define GPPUB 0x0d  // 1 - подтягивать , 0 - не подтягивать

#define INTFA 0x0e // Помогает определить на какой ножке произошло прерывание,  по умолчанию во всем
#define INTFB 0x0f  // регистре 0, произошло прерывание на порту в соответствующем разряде  появится 1

#define INTCAPA 0x10 // Регистр защелка, после прерывания происходит фиксация всех значений на портах на момент
#define INTCAPB 0x11 // прерывания,

#define GPIOA 0x12 // В этом регистре хранятся значения  на портах выставленных как входы 
#define GPIOB 0x13 // c помощью регистров IODIRA , IODIRB

#define OLATA 0x14 // В этом регистре выставляются значения на портах выбранными как выходы
#define OLATB 0x15 // c помощью регистров IODIRA , IODIRB

#define IOCON 0x0A     // Управляющие регистры дублируют друг друга.
#define IOCON2 0x0B  //
/*                              
bit 7  (BANK)  0 - 16 bit  представление регистров  
                       1 -   8 bit представление регистров   

bit 6 (Mirror)  0 -  выходы микросхемы INTA и INTB отвечают каждая за свои 8 портов
                       1-   выходы дублируют друг друга
 
bit5 (SEQOP)  0 -  при записи данных -  счетчик адресс  регистров увеличивается  
                        1 -  при записи данных - адресс регистров не изменяется
                        //8 битном режиме// - в один регистр
                        //16 битном режиме// - в два регистра последовательно
                                                             тоесть -> OLATA -> OLATB -> OLATA ->OLTAB 

bit4 (DISSLW)  0 -  помочь ведущему на линии опускать и поднимать ногу на линии
                       1 - не помогать ))
 
bit3                -  для микросхемы MCP23S17 (SPI) 
 
bit2 (ODR)      0  - ножки микросхемы INTA и INTB - цифровые   0 или 1
                      1 -  ножки микросхемы INTA и INTB - транзисторный выход (открытый коллетор)
                                ногу к резистору 10кОМ и к + (VDD),

bit1  (iNTPOL)  0 -  вслучаи прерывания активный сигнал 0, простой 1
                      1 -  вслучаи прерывания активный сигнал 1 , простой  0  
 */                     


  


#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <linux/i2c-dev.h>  // struct i2c_msg
#include <sys/ioctl.h>
#include <fcntl.h>
#include <linux/i2c.h> // struct i2c_rdwr_ioctl_data 

#include <linux/spi/spidev.h>

#define OK  0
#define ERORR -1



typedef struct {
     char *i2_bus;
 __int16_t  address;
 int       chip_open;
 int       bus_open;
  __int8_t registr[0x16];
}MCP23017;

MCP23017 chip1 = {"/dev/i2c-0",0x20};
MCP23017 chip2 = {"/dev/i2c-0",0x24};


//-------------------------------------  open i2C bus------------------------------------------------------//

int mcp23017_open_i2c(MCP23017 *chip){
    
        chip->bus_open = open( chip->i2_bus , O_RDWR);
    
        return chip->bus_open; };

//-------------------------------------  close i2c bus   ---------------------------------------------------//

int mcp23017_close_i2c (MCP23017 *chip){
    
    int chip_close = close(chip->bus_open);
        if (chip_close <0) perror("mcp23017 error close() I2C  ");
    
    return chip_close;};
    
//-------------------------------------- open chip for  read , write --------------------------------//

int mcp23017_open_read_write (MCP23017 *chip){
 
    if ( mcp23017_open_i2c (chip) < 0) {perror("mcp23017 error  open() I2C; ");
                                                            return chip->bus_open;}            // шины нет, выходим с ошибкой

        chip->chip_open = ioctl( chip->bus_open, I2C_SLAVE,chip->address);
            if ( chip->chip_open < 0 ) {perror("Устройство на шине I2C не найдено: ");
                                                    mcp23017_close_i2c (chip);
                                                    };
                
    return chip->chip_open;                                                              // устройство есть на шине, выходим
};  


//------------------------------------------ write bytes 8bit------------------------------------------//

__int8_t mcp23017_write_byte (MCP23017 *chip , __int8_t registr, __int8_t value){
  
 static __int8_t buf[2];
 
buf[0] = registr;                                           // buf[0]  - номер  регистра
buf[1] = value;                                             // buf[1]  - что писать в этот регистр
 
 if (mcp23017_open_i2c (chip) < 0)  return chip->bus_open;   
    
        struct i2c_msg msg [1] = {
                                                {chip->address, 0, 2, buf }                   //выставить адрес и записать
                                                }; 
        struct i2c_rdwr_ioctl_data rdwr = {msg, 1 };
         
            int chip_write  = ioctl(chip->bus_open, I2C_RDWR, &rdwr );
            if ( chip_write < 0 ) perror("I2C erorr rdwr");
                                    
        
  if ( mcp23017_close_i2c (chip) < 0){ perror("I2C erorr close() "); return -1;};
                                     
 return  chip_write;}


///----------------------------------------read  bytes 8bit ------------------------------------------------//

__int8_t mcp23017_read_byte (MCP23017 *chip, __int8_t registr){

   if (mcp23017_open_i2c (chip) < 0)  return chip->bus_open;  
   
   
   
    static __int8_t buf[1];
    buf[0]= registr;                                                                          //выставить регистр который читаем
   
    struct i2c_msg msg [2] = {
                                             {chip->address, 0, 1, buf },               //выставить адрес (методом записи)
                                             {chip->address, I2C_M_RD, 1, buf }    //прочитать данные в буфер
                                            };
    
   struct i2c_rdwr_ioctl_data rdwr = {msg, 2 };                                 //поместить массив  блоков (не больше 32 байт в блоке) 
                                                                                                      // структуру (на все дается 8192 байт)

        if ( ioctl(chip->bus_open, I2C_RDWR, &rdwr ) < 0 )
                                    { perror("I2C erorr rdwr");} 
                                    else {chip->registr[registr] = buf[0];}  //  при ок сохранить даннные в массив
   
  if ( mcp23017_close_i2c (chip) < 0){ perror("I2C erorr close() "); 
                                                           return -1;}
 

return chip->registr[registr];};

///------------------------------------------- i2c (mcp23017) emulation SPI  for max6675 -----------------------------------------------------///
// GPIOA BIT(0) - miso, BIT(1) - clk ,BIT(2) - cs 

int mcp23017_read_SPI (MCP23017 *chip){

if (mcp23017_open_i2c (chip) < 0)  return chip->bus_open; 

__int16_t temperatura = 0x0;
__int8_t buf_MISO[1] ;
__int8_t bit_miso = 0;
__int8_t buf_CLK[2] = {OLATA,0x02};

struct i2c_msg msgCLK [1] = {
                                            {chip->address, 0x0, 2, buf_CLK}
                                             };

struct i2c_msg msgMISO [2] ={
                                            {chip->address, 0x0, 1, buf_MISO},               //выставить адрес (методом записи)
                                            {chip->address, I2C_M_RD, 1, buf_MISO}
                                              };

 struct i2c_rdwr_ioctl_data CLK = {msgCLK, 1 };
 struct i2c_rdwr_ioctl_data MISO = {msgMISO, 2 };

 
 for(__int8_t i=0; i< 17; i++){
     
 buf_CLK[1]= 0x02;
     if ( ioctl(chip->bus_open, I2C_RDWR, &CLK ) < 0 ){ perror("I2C erorr CLK ");} ;

buf_MISO[0] = GPIOA;
    if ( ioctl(chip->bus_open, I2C_RDWR, &MISO ) < 0 ){ perror("I2C erorr MISO");} ;
             //bit_miso = buf_MISO[0]&0x01;
             temperatura = temperatura | (buf_MISO[0]&0x01);
                if (i <16) temperatura = temperatura << 1;
  
buf_CLK[1]= 0x00;
    if ( ioctl(chip->bus_open, I2C_RDWR, &CLK ) < 0 ){ perror("I2C erorr CLK");} ;         

 };

 temperatura = temperatura >> 5; 

if ( mcp23017_close_i2c (chip) < 0){ perror("I2C erorr close() "); 
                                                           return -1;}
 return temperatura;
};


//--------------------------------------------------------------- spi -----------------------------------------------------------------//





































// тесты

int main(int argc, char** argv) {
 
  
    
    
mcp23017_write_byte (&chip1, IODIRA, 0);
mcp23017_write_byte (&chip2, IODIRA, 0x1);
//mcp23017_write_byte (&chip2, OLATA, 0x04);

    
for(__int8_t i=0; i< 0x16; i++){
    
    printf("\n regist[%x] = %02x <--> regist[%x] = %02x"
                ,i
                ,mcp23017_read_byte(&chip1, i) 
                ,i
                , mcp23017_read_byte(&chip2,i)
            );
};


mcp23017_write_byte (&chip2, OLATA, 0x0);  //cs - enable
test:

printf(" \n temperatura %hd",mcp23017_read_SPI (&chip2));

mcp23017_write_byte (&chip2, OLATA, 0x04); //cs- disabled


sleep(1);

goto test;


return (EXIT_SUCCESS);
//for (__int8_t  i=0; i<255; i++){mcp23017_write_byte (&chip1, OLATA, i);sleep(1);};
//return (EXIT_SUCCESS);
}





/*
 
 
 
 */

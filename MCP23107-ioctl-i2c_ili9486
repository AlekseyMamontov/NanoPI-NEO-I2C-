/* To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 * File:   main.c
 * Author: Aleksey Mamontov
 * Created on 24 июня 2018 г., 23:05
 */

/*////////////// 8bit mode (IOCON.BANK = 1) ////////////////////////////

#define IODIRA 0x00
#define IODIRB 0x10
#define IPOLA  0x01
#define IPOLB  0x11
#define GPINTENA 0x02
#define GPINTENB 0x12
#define DEFVALA 0x03
#define DEFVALB 0x13
#define INTCONA 0x04
#define INTCONB 0x14
#define IOCON 0x05
#define IOCON2 0x15
#define GPPUA 0x06
#define GPPUB 0x016
#define INTFA 0x07
#define INTFB 0x017
#define INTCAPA 0x08
#define INTCAPB 0x18
#define GPIOA 0x09
#define GPIOB 0x19
#define OLATA 0x0a
#define OLATB 0x1a

 */
///////////////////// 16 bit mode  (IOCON.BANK = 0) ////////////////////

#define IODIRA 0x00 //  регистры указывают навправление входа и выхода для 16 портов
#define IODIRB 0x01 //  bit =1 - вход , bit = 0 выход, IODIRA - порты А0 - А7, ODIRB порты B0-В7

#define IPOLA  0x02 //  регистры отвечают за инверсию входных данных,  для портов  GPIOA - GPIOB
#define IPOLB  0x03 //  которые выставлены как вход (bit=1)  1 -> 0 или 0 ->1 :   (bit=0) 1->1 или 0->0

#define GPINTENA 0x04 //    Выставив  bit=1 мы определяем что данный порт может быть внешним прерыванием
#define GPINTENB 0x05 //    Прерывание происходит при смене напряжения.

#define DEFVALA 0x06 // В данных регистрах мы указываем при каком условии происходит прерывание
#define DEFVALB 0x07 // например bit=0 - то прерывание произойдет при  появление 1 (+3.3 до +5V)  на данном порту
                                    //  или bit=1 - тогда когда на порту появится 0 (GND,VSS) произойдет прерывание

#define INTCONA 0x08 // Если в этом регистре мы выставляем bit = 1 , то  определения для прерываний
#define INTCONB 0x09 // заданные в DEFVALA , DEFVAB игнорируются и прерывание происходит при условии
                                    // смены уровней тоесть 0 -> 1 прерывание  1-> 0 прерывание.

#define GPPUA 0x0c  // Подтягивать порты которые как входы к питанию через 100 кОм резистор
#define GPPUB 0x0d  // 1 - подтягивать , 0 - не подтягивать

#define INTFA 0x0e // Помогает определить на какой ножке произошло прерывание,  по умолчанию во всем
#define INTFB 0x0f  // регистре 0, произошло прерывание на порту в соответствующем разряде  появится 1

#define INTCAPA 0x10 // Регистр защелка, после прерывания происходит фиксация всех значений на портах на момент
#define INTCAPB 0x11 // прерывания,

#define GPIOA 0x12 // В этом регистре хранятся значения  на портах выставленных как входы
#define GPIOB 0x13 // c помощью регистров IODIRA , IODIRB

#define OLATA 0x14 // В этом регистре выставляются значения на портах выбранными как выходы
#define OLATB 0x15 // c помощью регистров IODIRA , IODIRB

#define IOCON 0x0A     // Управляющие регистры дублируют друг друга.
#define IOCON2 0x0B  //
/*
bit 7  (BANK)  0 - 16 bit  представление регистров
                       1 -   8 bit представление регистров

bit 6 (Mirror)  0 -  выходы микросхемы INTA и INTB отвечают каждая за свои 8 портов
                       1-   выходы дублируют друг друга

bit5 (SEQOP)  0 -  при записи данных -  счетчик адресс  регистров увеличивается
                        1 -  при записи данных - адресс регистров не изменяется
                        //8 битном режиме// - в один регистр
                        //16 битном режиме// - в два регистра последовательно
                                                             тоесть -> OLATA -> OLATB -> OLATA ->OLTAB

bit4 (DISSLW)  0 -  помочь ведущему на линии опускать и поднимать ногу на линии
                       1 - не помогать ))

bit3                -  для микросхемы MCP23S17 (SPI)

bit2 (ODR)      0  - ножки микросхемы INTA и INTB - цифровые   0 или 1
                      1 -  ножки микросхемы INTA и INTB - транзисторный выход (открытый коллетор)
                                ногу к резистору 10кОМ и к + (VDD),

bit1  (iNTPOL)  0 -  вслучаи прерывания активный сигнал 0, простой 1
                      1 -  вслучаи прерывания активный сигнал 1 , простой  0
 */





#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>
#include <linux/i2c-dev.h>  // struct i2c_msg
#include <sys/ioctl.h>

#include <linux/i2c.h> // struct i2c_rdwr_ioctl_data

#include <linux/spi/spidev.h>

#define OK  0
#define ERORR -1



typedef struct {
     char *i2_bus;
 __int16_t  address;
 int       chip_open;
 int       bus_open;
  __int8_t registr[0x16];
}MCP23017;

MCP23017 chip1 = {"/dev/i2c-0",0x20};
MCP23017 chip2 = {"/dev/i2c-0",0x24};
MCP23017 chip3 = {"/dev/i2c-0",0x22};







//-------------------------------------  open i2C bus------------------------------------------------------//

int mcp23017_open_i2c(MCP23017 *chip){

        chip->bus_open = open( chip->i2_bus , O_RDWR);

        return chip->bus_open; };

//-------------------------------------  close i2c bus   ---------------------------------------------------//

int mcp23017_close_i2c (MCP23017 *chip){

    int chip_close = close(chip->bus_open);
        if (chip_close <0) perror("mcp23017 error close() I2C  ");

    return chip_close;};

//-------------------------------------- check open chip for  read , write --------------------------------//

int mcp23017_open_read_write (MCP23017 *chip){

    if ( mcp23017_open_i2c (chip) < 0) {perror("mcp23017 error  open() I2C; ");
                                                            return chip->bus_open;}            // шины нет, выходим с ошибкой

        chip->chip_open = ioctl( chip->bus_open, I2C_SLAVE,chip->address);
            if ( chip->chip_open < 0 ) {perror("Устройство на шине I2C не найдено: ");
                                                    mcp23017_close_i2c (chip);
                                                    };

    return chip->chip_open;                                                              // устройство есть на шине, выходим
};


//------------------------------------------ write bytes 8bit------------------------------------------//

__int8_t mcp23017_write_byte (MCP23017 *chip , __int8_t registr, __int8_t value){

 static __int8_t buf[2];

buf[0] = registr;                                           // buf[0]  - номер  регистра
buf[1] = value;                                             // buf[1]  - что писать в этот регистр

 if (mcp23017_open_i2c (chip) < 0)  return chip->bus_open;

        struct i2c_msg msg [1] = {
                                                {chip->address, 0, 2, buf }                   //выставить адрес и записать
                                                };
        struct i2c_rdwr_ioctl_data rdwr = {msg, 1 };

            int chip_write  = ioctl(chip->bus_open, I2C_RDWR, &rdwr );
            if ( chip_write < 0 ) perror("I2C erorr rdwr");


  if ( mcp23017_close_i2c (chip) < 0){ perror("I2C erorr close() "); return -1;};

 return  chip_write;}


///----------------------------------------read  bytes 8bit ------------------------------------------------//

__int8_t mcp23017_read_byte (MCP23017 *chip, __int8_t registr){

   if (mcp23017_open_i2c (chip) < 0)  return chip->bus_open;



    static __int8_t buf[1];
    buf[0]= registr;                                                 //выставить регистр который читаем

    struct i2c_msg msg [2] = {
                               {chip->address, 0, 1, buf },          //выставить адрес (методом записи)
                               {chip->address, I2C_M_RD, 1, buf }    //прочитать данные в буфер
                                            };

   struct i2c_rdwr_ioctl_data rdwr = {msg, 2 };                     //поместить массив  блоков (не больше 32 байт в блоке)
                                                                    // структуру (на все дается 8192 байт)

        if ( ioctl(chip->bus_open, I2C_RDWR, &rdwr ) < 0 )
                                    { perror("I2C erorr rdwr");}
                                    else {chip->registr[registr] = buf[0];}  //  при ок сохранить даннные в массив

  if ( mcp23017_close_i2c (chip) < 0){ perror("I2C erorr close() ");
                                                           return -1;}


return chip->registr[registr];};

///------------------------------------------- i2c (mcp23017) emulation SPI  for max6675 -----------------------------------------------------///
// GPIOA BIT(0) - miso, BIT(1) - clk ,BIT(2) - cs

int mcp23017_read_SPI (MCP23017 *chip){

FILE *disp;
disp = fopen("/dev/tty1","w");

__int16_t temperatura = 0x0;
__int16_t temperatura1 = 0x0;

__int8_t buf_MISO[1] ={0} ;
__int8_t buf_CLK[2] = {OLATA,0x04};

__int8_t buf_RAW[17] = {0};


if (mcp23017_open_i2c (chip) < 0)  return chip->bus_open;

	struct i2c_msg msgCLK [1] = {
								{chip->address, 0x0, 2, buf_CLK}
};

	struct i2c_msg msgMISO [2] ={
                             {chip->address, 0x0, 1, buf_MISO},
                             {chip->address, I2C_M_RD, 1, buf_MISO}
};

	struct i2c_rdwr_ioctl_data CLK = {msgCLK, 1 };
	struct i2c_rdwr_ioctl_data MISO = {msgMISO, 2 };

//  в этом цикле считываются 16 бит данных сразу с нескольких MAX6675,
//  за один проход от 1 до 6шт. пины 7-CS, 6 -CLK , 5-0  MAX6675  
   

		for(__int8_t i=0; i< 17; i++){

		buf_CLK[1]= 0x04;
		if ( ioctl(chip->bus_open, I2C_RDWR, &CLK ) < 0 ){
				perror("I2C erorr CLK ");};

		buf_MISO[0] = GPIOA;
		if ( ioctl(chip->bus_open, I2C_RDWR, &MISO ) < 0 ){
				perror("I2C erorr MISO");};
		
		buf_RAW [i] = buf_MISO[0]; 

		buf_CLK[1] = 0x00;
		if ( ioctl(chip->bus_open, I2C_RDWR, &CLK ) < 0 ){
				perror("I2C erorr CLK");};

		};

		//  выключить микросхемы

		buf_CLK[1]= 0x08;
		if ( ioctl(chip->bus_open, I2C_RDWR, &CLK ) < 0 ){
				perror("I2C erorr CS");};

		// Обработать данные
		
		for(__int8_t i=0; i< 17; i++){

				temperatura = temperatura | (buf_RAW[i]&0x01);
				temperatura1 = temperatura1 | ((buf_RAW[i]&0x02) >> 1);
				
                if (i <16) {temperatura = temperatura << 1 ;
							temperatura1 = temperatura1 << 1 ;
					
					};
		};



	temperatura = temperatura >> 5;
	temperatura1 = temperatura1 >> 5;
	
	if ( mcp23017_close_i2c (chip) < 0){
			perror("I2C erorr close() ");
			return -1;}


fprintf(disp,"\033[%d;%dH \033[%dm \e[1m Температура,C \033[0m \033[%d;%dH %hd",01,20,42,2,22,temperatura);
fprintf(disp,"\033[%d;%dH \033[%dm \e[1m Температура,C \033[0m \033[%d;%dH %hd",03,20,42,4,22,temperatura1);
fclose(disp);


 return temperatura1;
};

//--------------------------------------------------------------- testy ili9486 (81)-----------------------------------------------------------------//

///////////////////////////////////////////// COMMAND ///////////////////////////////////////////////////////////////

int8_t write_tft_command (MCP23017 *chip ,__int8_t value){

 __int8_t buf[3] = {OLATA, value, 0b00011000};
 static __int8_t buf2[2] = {OLATB,0b00011001};														// buf[0]  - номер  регистра
																									// buf[1]  - что писать в этот регис

 //if (mcp23017_open_i2c (chip) < 0)  return chip->bus_open;

        struct i2c_msg msg [1] = {{chip->address, 0, 3, buf}};
        struct i2c_rdwr_ioctl_data rdwr = {msg,1};
		struct i2c_msg msg2 [1] = {{chip->address, 0, 2, buf2}};
        struct i2c_rdwr_ioctl_data rdwr2 = {msg2,1};

        int chip_write  = ioctl(chip->bus_open, I2C_RDWR, &rdwr );
				if ( chip_write < 0 ) perror("I2C erorr rdwr");

			chip_write  = ioctl(chip->bus_open, I2C_RDWR, &rdwr2 );
				if ( chip_write < 0 ) perror("I2C erorr rdwr");


  //if ( mcp23017_close_i2c (chip) < 0){ perror("I2C erorr close() "); return -1;};

 return  chip_write;}
 
//////////////////////////////////////////// DATA ///////////////////////////////////////////////////

int8_t write_tft_data(MCP23017 *chip ,__int8_t value){

 
 __int8_t buf[3] = {OLATA, value, 0b00011100};
 static __int8_t buf2[2] = {OLATB,0b00011101};														// buf[0]  - номер  регистра
																									// buf[1]  - что писать в этот регис

 //if (mcp23017_open_i2c (chip) < 0)  return chip->bus_open;

        struct i2c_msg msg [1] = {{chip->address, 0, 3, buf}};
        struct i2c_rdwr_ioctl_data rdwr = {msg,1};
		struct i2c_msg msg2 [1] = {{chip->address, 0, 2, buf2}};
        struct i2c_rdwr_ioctl_data rdwr2 = {msg2,1};

        int chip_write  = ioctl(chip->bus_open, I2C_RDWR, &rdwr );
				if ( chip_write < 0 ) perror("I2C erorr rdwr");

			chip_write  = ioctl(chip->bus_open, I2C_RDWR, &rdwr2 );
				if ( chip_write < 0 ) perror("I2C erorr rdwr");


 // if ( mcp23017_close_i2c (chip) < 0){ perror("I2C erorr close() "); return -1;};

 return  chip_write;}



/////////////////////////////////////////////////////////////////////


void ili9486(){
 write_tft_command (&chip3,0xb0);
 write_tft_command (&chip3,0x00);
 write_tft_command (&chip3,0x11);
 
 write_tft_command (&chip3,0x3A);
	write_tft_data (&chip3,0x55);
 write_tft_command (&chip3,0xC2);
	write_tft_data (&chip3,0x44);
 
 write_tft_command (&chip3,0xC5);
	write_tft_data (&chip3,0x00);
	write_tft_data (&chip3,0x00);
	write_tft_data (&chip3,0x00);
	write_tft_data (&chip3,0x00);
write_tft_command (&chip3,0xE0);
	write_tft_data (&chip3,0x0f);
	write_tft_data (&chip3,0x1f);
	write_tft_data (&chip3,0x1c);
	write_tft_data (&chip3,0x0c);
	write_tft_data (&chip3,0x0f);
	write_tft_data (&chip3,0x08);
	write_tft_data (&chip3,0x48);
	write_tft_data (&chip3,0x98);
	write_tft_data (&chip3,0x37);
	write_tft_data (&chip3,0x0a);
	write_tft_data (&chip3,0x13);
	write_tft_data (&chip3,0x04);
	write_tft_data (&chip3,0x11);
	write_tft_data (&chip3,0x0d);
	write_tft_data (&chip3,0x00);

write_tft_command (&chip3,0xE1);
	write_tft_data (&chip3,0x0f);
	write_tft_data (&chip3,0x32);
	write_tft_data (&chip3,0x2e);
	write_tft_data (&chip3,0x0b);
	write_tft_data (&chip3,0x0d);
	write_tft_data (&chip3,0x05);
	write_tft_data (&chip3,0x47);
	write_tft_data (&chip3,0x75);
	write_tft_data (&chip3,0x37);
	write_tft_data (&chip3,0x06);
	write_tft_data (&chip3,0x10);
	write_tft_data (&chip3,0x03);
	write_tft_data (&chip3,0x24);
	write_tft_data (&chip3,0x20);
	write_tft_data (&chip3,0x00);

		
write_tft_command (&chip3,0xE2);
	write_tft_data (&chip3,0x0f);
	write_tft_data (&chip3,0x32);
	write_tft_data (&chip3,0x2e);
	write_tft_data (&chip3,0x0b);
	write_tft_data (&chip3,0x0d);
	write_tft_data (&chip3,0x05);
	write_tft_data (&chip3,0x47);
	write_tft_data (&chip3,0x75);
	write_tft_data (&chip3,0x37);
	write_tft_data (&chip3,0x06);
	write_tft_data (&chip3,0x10);
	write_tft_data (&chip3,0x03);
	write_tft_data (&chip3,0x24);
	write_tft_data (&chip3,0x20);
	write_tft_data (&chip3,0x00);
	
 write_tft_command (&chip3,0x11);
 
 write_tft_command (&chip3,0x20);
 
 write_tft_command (&chip3,0x36);
	write_tft_data (&chip3,0x0a);
 
 
 write_tft_command (&chip3,0x29);
 
 
 
 		
	};

void ili9481(){
	
write_tft_command (&chip3,0x11);
 sleep(1);
 write_tft_command (&chip3,0xd0);
	write_tft_data (&chip3,0x07);	
	write_tft_data (&chip3,0x42);
	write_tft_data (&chip3,0x18);
	
 write_tft_command (&chip3,0xd1);
	write_tft_data (&chip3,0x00);
	write_tft_data (&chip3,0x07);	
	write_tft_data (&chip3,0x10);
	
write_tft_command (&chip3,0xd2);
	write_tft_data (&chip3,0x01);
	write_tft_data (&chip3,0x02);		
	
write_tft_command (&chip3,0xC0);
	write_tft_data (&chip3,0x10);
	write_tft_data (&chip3,0x3b);
	write_tft_data (&chip3,0x00);
	write_tft_data (&chip3,0x02);
	write_tft_data (&chip3,0x11);	

write_tft_command (&chip3,0xc5);
	write_tft_data (&chip3,0x03);
	

write_tft_command (&chip3,0xc8);
	write_tft_data (&chip3,0x00);
	write_tft_data (&chip3,0x32);
	write_tft_data (&chip3,0x36);
	write_tft_data (&chip3,0x45);
	write_tft_data (&chip3,0x06);
	write_tft_data (&chip3,0x16);
	write_tft_data (&chip3,0x37);
	write_tft_data (&chip3,0x75);
	write_tft_data (&chip3,0x77);
	write_tft_data (&chip3,0x54);
	write_tft_data (&chip3,0x0c);
	write_tft_data (&chip3,0x00);
		
write_tft_command (&chip3,0x36);
	write_tft_data (&chip3,0x0a);
		
write_tft_command (&chip3,0x3A);
	write_tft_data (&chip3,0x55);
		
write_tft_command (&chip3,0x2a);
	write_tft_data (&chip3,0x00);
	write_tft_data (&chip3,0x00);
	write_tft_data (&chip3,0x01);
	write_tft_data (&chip3,0x3f);		
		
write_tft_command (&chip3,0x2b);
	write_tft_data (&chip3,0x00);
	write_tft_data (&chip3,0x00);
	write_tft_data (&chip3,0x01);
	write_tft_command (&chip3,0xE0);	
		
write_tft_command (&chip3,0x21);		
//sleep(1);
 write_tft_command (&chip3,0x29);	
 

 
	};

int setAddrWindow(int x0, int y0, int x1, int y1) {
write_tft_command (&chip3,0x2A);
write_tft_data (&chip3,x0 >> 8);
write_tft_data (&chip3,x0 & 0xFF);
write_tft_data (&chip3,x1 >> 8);
write_tft_data (&chip3,x1 & 0xFF);
write_tft_command (&chip3,0x2b);
write_tft_data (&chip3,y0 >> 8);
write_tft_data (&chip3,y0 & 0xFF);
write_tft_data (&chip3,y1 >> 8);
write_tft_data (&chip3,y1 & 0xFF);
write_tft_command (&chip3,0x2c);
}



void disp(){
	
 write_tft_command (&chip3,0x36);	
 write_tft_data (&chip3,0x28);	  //rotation 90
	
	// заполнить память из буфера и одним байтом...
	
write_tft_command (&chip3,0x2a);
write_tft_data (&chip3,0);
write_tft_data (&chip3,0);
write_tft_data (&chip3,0x01);
write_tft_data (&chip3,0xe0);
write_tft_command (&chip3,0x2b);
write_tft_data (&chip3,0x00);
write_tft_data (&chip3,0x0);
write_tft_data (&chip3,0x01);
write_tft_data (&chip3,0x40);
write_tft_command (&chip3,0x2c);
	
	
	for( int i=0; i< 320000; i++)
{
	write_tft_data (&chip3,00);
	
};

	};
























//////-------------------------------------------------------------------



int main(int argc, char** argv) {


mcp23017_write_byte (&chip3, IODIRA,0xff);
mcp23017_write_byte (&chip3, IODIRB,0xff);


mcp23017_write_byte (&chip3, OLATA, 0x00);
mcp23017_write_byte (&chip3, OLATB, 0xff);

mcp23017_write_byte (&chip3, IODIRA,0);
mcp23017_write_byte (&chip3, IODIRB,0);


mcp23017_write_byte (&chip3, OLATB, 0b00011111);
sleep(1);
mcp23017_write_byte (&chip3, OLATB, 0b00010111);
sleep(1);
mcp23017_write_byte (&chip3, OLATB, 0b00011111);
sleep(1);
mcp23017_write_byte (&chip3, OLATB, 0b00011101);



if (mcp23017_open_i2c (&chip3) < 0)  { perror("I2C erorr open() "); return -1;};
 
ili9486();
disp();

if ( mcp23017_close_i2c (&chip3) < 0){ perror("I2C erorr close() "); return -1;};


mcp23017_write_byte (&chip3, OLATB, 0b00011111);	

printf ("test \n");






return 0;

};
